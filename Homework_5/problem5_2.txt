===============================================================================

a) Derive the asymptotic time complexity depending on the number of bits n for 
a brute-force implementation of the multiplication.

a) The time complexity for such an algorithm is O(n^2). They way it would work 
is similiar to grade school long multiplication where each bit of a is 
multiplied with the bits of b (multiplication is just the "&" operator), and 
then everything would be added up to get the final result. This would be done
using a nested for loop where the outer loop would iterate through the bits of
a, while the inner one through the bits of b.

===============================================================================

b) Derive a Divide & Conquer algorithm for the given problem by splitting the
problem into two subproblems. For simplicity you can assume n to be a power of 
2.

b) Here is the pseudocode:

multiply(a,b) {
    if a.bits < 2 {
        return a*b;
    }
    a1 = a[0..n/2];
    a2 = a[(n/2) + 1..n];

    b1 = b[0..n/2];
    b2 = b[(n/2) + 1..n];

    a1b1 = multiply(a1, b1);
    a2b2 = multiply(a2, b2);
    c = multiply(a1 + a2, b1 + b2);

    return pow(2,n)*a1b1 + pow(2,n/2)*(c - a1b1 - a2b2) + a2b2;
}

===============================================================================

c) Derive a recurrence for the time complexity of the Divide & Conquer 
algorithm you developed for subpoint (b).

c) Here is the time analysis:

multiply(a,b) {                         
    if a.bits < 2 {                                             //O(n)
        return a*b;
    }
    a1 = a[0..n/2];                                             //O(n)
    a2 = a[(n/2) + 1..n];                                       //O(n)

    b1 = b[0..n/2];                                             //O(n)
    b2 = b[(n/2) + 1..n];                                       //O(n)

    a1b1 = multiply(a1, b1);                                    //T(n/2)
    a2b2 = multiply(a2, b2);                                    //T(n/2)
    c = multiply(a1 + a2, b1 + b2);                             //O(n) + T(n/2)

    return pow(2,n)*a1b1 + pow(2,n/2)*(c - a1b1 - a2b2) + a2b2; //O(n)
}

T(n) = 3T(n/2) + O(n)

===============================================================================

d) Solve the recurrence in subpoint (c) using the recursion tree method

d) see time_complexity.pdf page 1

===============================================================================

e) Validate the result you got in subpoint (d) by using the master theorem to 
solve the recurrence again.

e) see time_complexity.pdf page 2

===============================================================================