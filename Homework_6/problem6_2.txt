===============================================================================

a) Implement the Heap Sort algorithm as presented in the lecture.

a) see heap_sort.cpp

===============================================================================

b) Implement a variant of the Heap Sort that works as follows: In the first 
step it also builds a max-heap. In the second step, it also proceeds as the 
Heap Sort does, but instead of calling M AX-HEAP IF Y , it always floats the 
new root all the way down to aleaf level. Then, it checks whether that was 
actually correct and if not fixes the max-heap bymoving the element up again. 
This strategy makes sense when considering that the element that was swapped to
become the new root is typically small and thus would float down to a leaf 
level in most cases. Hence, one would save the additional tests when floating 
down the element. And, the fixing step (moving the element upwards again) would
be a rare case. This variant is called Bottom-up Heap Sort.

b) see heap_sort_variant.cpp

===============================================================================

c) Compare the original Heap Sort and its variant from subpoint (b) for input 
sequences of different lengths (including larger input sequences). What can you
observe?

c) Looking at the graph, it can be concluded that the variant of Heap Sort is 
indeed slightly faster than the original version. However, this only becomes 
apparent for larger values of n, where even then the sorting algorithms do not
seem to have much of a difference from each other, asymptotically speaking. The
algorithms only differ by some constant "c", meaning that the overall time 
complexity is still the same for both (O(nlogn)).

===============================================================================