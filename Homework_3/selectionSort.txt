a) Implement Selection Sort.

a) See selectionSort.cpp

===============================================================================

b) Show that Selection Sort is correct (Hint: consider the loop invariant).

b) The Loop Invariant in Selection Sort is the same as the one we had in 
Insertion Sort: the left side of the array (the elements we've already loop 
through) are always sorted.

===============================================================================

c) enerate random input sequences of length n as well as sequences of length
n that represent Case A and Case B for the Selection Sort algorithm. Case A: 
the case which involves the most swaps (Hint: it is not a decreasingly ordered 
array). Case B: the case with the least swaps. Briefly describe how you 
generated the sequences (e.g., with a random sequence generator using your 
chosen language).


c) In order to generate random numbers, I used the functions rand() and 
srand(). 

Case Random/Average: I didn't do anything special here. I just simply generated
random numbers and put them in the deques.

Case A: I generated a sequence of ascending numbers and then moved the last
element (the largest element) to the front of the deque before the sorting. 
This  way, the number of swaps will always be size-1 since the largest element 
will have  to be moved in every iteration. 

Case B: I used the same sequence generator as in Case A, but this time I did 
not move any elements around before the sorting. Here, the number of swaps will 
always be 0, since the deque is already sorted.

===============================================================================

d) Run the algorithm on the sequences from (c) with length n for increasing 
values of n and measure the computation times. Plot curves that show the 
computation time of the algorithm in Case A, Case B, and average case for an 
increasing input length n. Note that in order to compute reliable measurements 
for the average case, you have to run the algorithm multiple times for each 
entry in your plot. You can use a plotting tool/software of your choice 
(Gnuplot, R, Matlab, Excel, etc.)

d) See computationTimes.py

===============================================================================

e) Interpret the plots from (d) with respect to asymptotic behavior and 
constants.

e) Looking at the plots, it is clear that as the number of elements grows, so 
doesthe computation time. The time complexity seems to be O(n^2). In addition,
it can also be infered that the number of swaps does not really affect the 
computation time. This makes sense when considering how the algorithm works; it
will run through every element in the list no matter what, and it will look for 
the smallest element in each iteration.  


